<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Making colorschemes · ColorSchemeTools</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="ColorSchemeTools logo"/></a><h1>ColorSchemeTools</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="tools.html">Tools</a></li><li><a class="toctext" href="convertingimages.html">Converting image colors</a></li><li class="current"><a class="toctext" href="makingschemes.html">Making colorschemes</a><ul class="internal"><li><a class="toctext" href="#Linearly-segmented-colors-1">Linearly-segmented colors</a></li><li><a class="toctext" href="#Indexed-list-color-schemes-1">Indexed-list color schemes</a></li><li><a class="toctext" href="#Functional-color-schemes-1">Functional color schemes</a></li></ul></li><li><a class="toctext" href="output.html">Saving colorschemes</a></li><li><a class="toctext" href="functionindex.html">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="makingschemes.html">Making colorschemes</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphics/ColorSchemeTools.jl/blob/master/docs/src/makingschemes.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Making colorschemes</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="Making-new-colorschemes-1" href="#Making-new-colorschemes-1">Making new colorschemes</a></h1><p>To make new ColorSchemes, you can use <code>make_colorscheme()</code>, and supply information about the color sequences in various formats:</p><ul><li>linearly-segmented dictionary</li><li>&#39;indexed list&#39;</li><li>defined by three functions</li></ul><h2><a class="nav-anchor" id="Linearly-segmented-colors-1" href="#Linearly-segmented-colors-1">Linearly-segmented colors</a></h2><p>A linearly-segmented color dictionary looks like this:</p><pre><code class="language-none">cdict = Dict(:red  =&gt; ((0.0,  0.0,  0.0),
                       (0.5,  1.0,  1.0),
                       (1.0,  1.0,  1.0)),
            :green =&gt; ((0.0,  0.0,  0.0),
                       (0.25, 0.0,  0.0),
                       (0.75, 1.0,  1.0),
                       (1.0,  1.0,  1.0)),
            :blue =&gt;  ((0.0,  0.0,  0.0),
                       (0.5,  0.0,  0.0),
                       (1.0,  1.0,  1.0)))</code></pre><p>The first number in each tuple for each color increases from 0 to 1, the second and third determine the color values. (TODO - how exactly?)</p><p>To create a new ColorScheme from a suitable dictionary, call <code>make_colorscheme()</code>.</p><pre><code class="language-none">using Colors, ColorSchemes
scheme = make_colorscheme(dict)</code></pre><p>By plotting the color components separately it&#39;s possible to see how the curves change. This diagram both the defined color levels and a continuously-sampled image:</p><div><pre><code class="language-julia">cdict = Dict(:red  =&gt; ((0.0,  0.0,  0.0),
                       (0.5,  1.0,  1.0),
                       (1.0,  1.0,  1.0)),
            :green =&gt; ((0.0,  0.0,  0.0),
                       (0.25, 0.0,  0.0),
                       (0.75, 1.0,  1.0),
                       (1.0,  1.0,  1.0)),
            :blue =&gt;  ((0.0,  0.0,  0.0),
                       (0.5,  0.0,  0.0),
scheme = make_colorscheme(cdict)</code></pre></div><p><img src="assets/figures/curves.svg" alt="&quot;showing linear segmented colorscheme&quot;"/></p><p>If you want to save an image of this, use <code>colorscheme_to_image()</code>:</p><pre><code class="language-none">using ColorSchemes, ColorSchemeTools, FileIO
img = colorscheme_to_image(ColorScheme(scheme), 450, 60)
save(&quot;/tmp/linseg.png&quot;, img)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ColorSchemeTools.get_linear_segment_color" href="#ColorSchemeTools.get_linear_segment_color"><code>ColorSchemeTools.get_linear_segment_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_linear_segment_color(dict, n)</code></pre><p>Get the RGB color for value <code>n</code> from a dictionary of linear color segments.</p><p>A dictionary where red increases from 0 to 1 over the bottom half, green does the same over the middle half, and blue over the top half, looks like this:</p><pre><code class="language-none">cdict = Dict(:red  =&gt; ((0.0,  0.0,  0.0),
                       (0.5,  1.0,  1.0),
                       (1.0,  1.0,  1.0)),
            :green =&gt; ((0.0,  0.0,  0.0),
                       (0.25, 0.0,  0.0),
                       (0.75, 1.0,  1.0),
                       (1.0,  1.0,  1.0)),
            :blue =&gt;  ((0.0,  0.0,  0.0),
                       (0.5,  0.0,  0.0),
                       (1.0,  1.0,  1.0)))</code></pre><p>The value of RGB component at every value of <code>n</code> is defined by a set of tuples. In each tuple, the first number is <code>x</code>. Colors are linearly interpolated in bands between consecutive values of <code>x</code>; if the first tuple is given by <code>(Z, A, B)</code> and the second tuple by <code>(X, C, D)</code>, the color of a point <code>n</code> between Z and X will be given by <code>(n - Z) / (X - Z) * (C - B) + B</code>.</p><p>For example, given an entry like this:</p><pre><code class="language-none">:red  =&gt; ((0.0, 0.0, 0.0),
          (0.5, 1.0, 1.0),
          (1.0, 1.0, 1.0))</code></pre><p>and if <code>n</code> = 0.75, we return 1.0; 0.75 is between the second and third segments, but we&#39;d already reached 1.0 (segment 2) when <code>n</code> was 0.5.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/ColorSchemeTools.jl/blob/3602d8c136d59a20643b46a0fa4e1118a7a4ac64/src/ColorSchemeTools.jl#L238-L276">source</a></section><h2><a class="nav-anchor" id="Indexed-list-color-schemes-1" href="#Indexed-list-color-schemes-1">Indexed-list color schemes</a></h2><p>An &#39;indexed list&#39; color scheme looks like this:</p><pre><code class="language-none">terrain = (
           (0.00, (0.2, 0.2,  0.6)),
           (0.15, (0.0, 0.6,  1.0)),
           (0.25, (0.0, 0.8,  0.4)),
           (0.50, (1.0, 1.0,  0.6)),
           (0.75, (0.5, 0.36, 0.33)),
           (1.00, (1.0, 1.0,  1.0))
          )</code></pre><p>The first element in each is the location between 0 and 1, the second specifies the RGB values at that point.</p><p>The <code>make_colorscheme(indexedlist)</code> function makes a new ColorScheme from such an indexed list.</p><pre><code class="language-none">make_colorscheme(terrain)</code></pre><div><pre><code class="language-julia">terrain_data = (
        (0.00, (0.2, 0.2, 0.6)),
        (0.15, (0.0, 0.6, 1.0)),
        (0.25, (0.0, 0.8, 0.4)),
        (0.50, (1.0, 1.0, 0.6)),
        (0.75, (0.5, 0.36, 0.33)),
        (1.00, (1.0, 1.0, 1.0)))
terrain = make_colorscheme(terrain_data, length = 20)</code></pre></div><p><img src="assets/figures/terrain.svg" alt="&quot;indexed lists scheme&quot;"/></p><h2><a class="nav-anchor" id="Functional-color-schemes-1" href="#Functional-color-schemes-1">Functional color schemes</a></h2><p>The colors in a &#39;functional&#39; color scheme are produced by three functions that calculate the color values at each point on the scheme.</p><p>The <code>make_colorscheme()</code> function applies the first supplied function at each point on the colorscheme for the red values, the second function for the green values, and the third for the blue. You can use defined functions or supply anonymous ones.</p><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><p>This example returns a smooth black to white gradient, because the <code>identity()</code> function gives back as good as it gets.</p><div><pre><code class="language-julia">fscheme = make_colorscheme(identity, identity, identity)</code></pre></div><p><img src="assets/figures/funcscheme1.svg" alt="&quot;functional color schemes&quot;"/></p><p>This next example uses the <code>sin()</code> function on values from 0 to π to control the red, and the <code>cos()</code> function from 0 to π to control the blue.</p><div><pre><code class="language-julia">fscheme = make_colorscheme((n) -&gt; sin(n*π), (n) -&gt; 0, (n) -&gt; cos(n*π))</code></pre></div><p><img src="assets/figures/funcscheme2.svg" alt="&quot;functional color schemes&quot;"/></p><p>You can generate stepped gradients by controlling the numbers. Here, each point on the scheme is nudged to the nearest multiple of 0.1.</p><div><pre><code class="language-julia">fscheme = make_colorscheme(
        (n) -&gt; round(n, digits=1),
        (n) -&gt; round(n, digits=1),
        (n) -&gt; round(n, digits=1), length=10)</code></pre></div><p><img src="assets/figures/funcscheme3.svg" alt="&quot;functional color schemes&quot;"/></p><p>This example sends the red channel from black to red and back again.</p><div><pre><code class="language-julia">fscheme = make_colorscheme(n -&gt; sin(n * π), (n) -&gt; 0, (n) -&gt; 0)</code></pre></div><p><img src="assets/figures/funcscheme4.svg" alt="&quot;functional color schemes&quot;"/></p><p>This example produces a stripey colorscheme as the rippling sine waves continually change phase:</p><div><pre><code class="language-julia">ripple7(n) = sin(π * 7n)
ripple13(n) = sin(π * 13n)
ripple17(n) = sin(π * 17n)
fscheme = make_colorscheme(ripple7, ripple13, ripple17, length=80)</code></pre></div><p><img src="assets/figures/funcscheme5.svg" alt="&quot;functional color schemes&quot;"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ColorSchemeTools.make_colorscheme" href="#ColorSchemeTools.make_colorscheme"><code>ColorSchemeTools.make_colorscheme</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">make_colorscheme(dict;
    length=100)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/ColorSchemeTools.jl/blob/3602d8c136d59a20643b46a0fa4e1118a7a4ac64/src/ColorSchemeTools.jl#L298-L301">source</a><div><div><pre><code class="language-none">make_colorscheme(indexedlist, name::Symbol;
    length=100)</code></pre><p>Make a colorscheme using an &#39;indexed list&#39; like this:</p><pre><code class="language-none">gist_rainbow = (
       (0.000, (1.00, 0.00, 0.16)),
       (0.030, (1.00, 0.00, 0.00)),
       (0.215, (1.00, 1.00, 0.00)),
       (0.400, (0.00, 1.00, 0.00)),
       (0.586, (0.00, 1.00, 1.00)),
       (0.770, (0.00, 0.00, 1.00)),
       (0.954, (1.00, 0.00, 1.00)),
       (1.000, (1.00, 0.00, 0.75))
)

make_colorscheme(gist_rainbow)</code></pre><p>The first element of this list of tuples is the point on the color scheme.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/ColorSchemeTools.jl/blob/3602d8c136d59a20643b46a0fa4e1118a7a4ac64/src/ColorSchemeTools.jl#L359-L381">source</a><div><div><pre><code class="language-none">make_colorscheme(redfunction::Function, greenfunction::Function, bluefunction::Function;
        length=100)</code></pre><p>Make a colorscheme using functions. Each function should return a value between 0 and 1 for that color component at each point on the colorscheme.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/ColorSchemeTools.jl/blob/3602d8c136d59a20643b46a0fa4e1118a7a4ac64/src/ColorSchemeTools.jl#L390-L396">source</a></section><footer><hr/><a class="previous" href="convertingimages.html"><span class="direction">Previous</span><span class="title">Converting image colors</span></a><a class="next" href="output.html"><span class="direction">Next</span><span class="title">Saving colorschemes</span></a></footer></article></body></html>
