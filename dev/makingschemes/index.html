<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Making colorschemes · ColorSchemeTools</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="ColorSchemeTools logo"/></a><h1>ColorSchemeTools</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../tools/">Tools</a></li><li><a class="toctext" href="../convertingimages/">Converting image colors</a></li><li class="current"><a class="toctext" href>Making colorschemes</a><ul class="internal"><li><a class="toctext" href="#Linearly-segmented-colors-1">Linearly-segmented colors</a></li><li><a class="toctext" href="#Indexed-list-color-schemes-1">Indexed-list color schemes</a></li><li><a class="toctext" href="#Functional-color-schemes-1">Functional color schemes</a></li></ul></li><li><a class="toctext" href="../output/">Saving colorschemes</a></li><li><a class="toctext" href="../functionindex/">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Making colorschemes</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphics/ColorSchemeTools.jl/blob/master/docs/src/makingschemes.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Making colorschemes</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="Making-new-colorschemes-1" href="#Making-new-colorschemes-1">Making new colorschemes</a></h1><p>There are a few functions that can make new ColorSchemes:</p><ul><li><code>make_linear_segment_colorscheme()</code></li><li><code>make_indexed_list_colorscheme()</code></li><li><code>make_functional_colorscheme()</code></li></ul><h2><a class="nav-anchor" id="Linearly-segmented-colors-1" href="#Linearly-segmented-colors-1">Linearly-segmented colors</a></h2><p>A linearly-segmented color dictionary looks like this:</p><pre><code class="language-none">hsvdict = Dict(:red =&gt; ((0., 1., 1.),
                       (0.158730, 1.000000, 1.000000),
                       (0.174603, 0.968750, 0.968750),
                       (0.333333, 0.031250, 0.031250),
                       (0.349206, 0.000000, 0.000000),
                       (0.666667, 0.000000, 0.000000),
                       (0.682540, 0.031250, 0.031250),
                       (0.841270, 0.968750, 0.968750),
                       (0.857143, 1.000000, 1.000000),
                       (1.0, 1.0, 1.0)),
             :green =&gt; ((0., 0., 0.),
                       (0.158730, 0.937500, 0.937500),
                       (0.174603, 1.000000, 1.000000),
                       (0.507937, 1.000000, 1.000000),
                       (0.666667, 0.062500, 0.062500),
                       (0.682540, 0.000000, 0.000000),
                       (1.0, 0., 0.)),
             :blue =&gt;  ((0., 0., 0.),
                       (0.333333, 0.000000, 0.000000),
                       (0.349206, 0.062500, 0.062500),
                       (0.507937, 1.000000, 1.000000),
                       (0.841270, 1.000000, 1.000000),
                       (0.857143, 0.937500, 0.937500),
                       (1.0, 0.09375, 0.09375)))</code></pre><p>The first number in each tuple for each color increases from 0 to 1, the second and third determine the color values. (TODO - how exactly?)</p><p>To create a new ColorScheme from this, call <code>make_linear_segment_colorscheme()</code>.</p><pre><code class="language-none">using Colors, ColorSchemes
scheme = make_linear_segment_colorscheme(hsvdict)</code></pre><p>Save an image of this:</p><pre><code class="language-none">using ColorSchemes, FileIO
img = colorscheme_to_image(ColorScheme(scheme), 450, 60)
save(&quot;/tmp/linseg.png&quot;, img)</code></pre><p><img src="../assets/figures/linearsegmentedcolors.png" alt="&quot;linear segmented colorscheme&quot;"/></p><p>By plotting the color components separately it&#39;s possible to see how the curves change. This is what the <code>hsv</code> scheme looks like:</p><div></div><p><img src="../assets/figures/hsvcurves.svg" alt="&quot;hsv linear segmented colorscheme&quot;"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ColorSchemeTools.get_linear_segment_color" href="#ColorSchemeTools.get_linear_segment_color"><code>ColorSchemeTools.get_linear_segment_color</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">get_linear_segment_color(dict, n)</code></pre><p>Get the RGB color for value <code>n</code> from a dictionary of linear color segments.</p><p>A dictionary where red increases from 0 to 1 over the bottom half, green does the same over the middle half, and blue over the top half, looks like this:</p><pre><code class="language-none">cdict = Dict(:red  =&gt; ((0.0,  0.0,  0.0),
                       (0.5,  1.0,  1.0),
                       (1.0,  1.0,  1.0)),
            :green =&gt; ((0.0,  0.0,  0.0),
                       (0.25, 0.0,  0.0),
                       (0.75, 1.0,  1.0),
                       (1.0,  1.0,  1.0)),
            :blue =&gt;  ((0.0,  0.0,  0.0),
                       (0.5,  0.0,  0.0),
                       (1.0,  1.0,  1.0)))</code></pre><p>The value of RGB component at every value of <code>n</code> is defined by a set of tuples. In each tuple, the first number is <code>x</code>. Colors are linearly interpolated in bands between consecutive values of <code>x</code>; if the first tuple is given by <code>(Z, A, B)</code> and the second tuple by <code>(X, C, D)</code>, the color of a point <code>n</code> between Z and X will be given by <code>(n - Z) / (X - Z) * (C - B) + B</code>.</p><p>For example, given an entry like this:</p><pre><code class="language-none">:red  =&gt; ((0.0, 0.0, 0.0),
          (0.5, 1.0, 1.0),
          (1.0, 1.0, 1.0))</code></pre><p>and if <code>n</code> = 0.75, we return 1.0; 0.75 is between the second and third segments, but we&#39;d already reached 1.0 (segment 2) when <code>n</code> was 0.5.</p></div></div></section><h2><a class="nav-anchor" id="Indexed-list-color-schemes-1" href="#Indexed-list-color-schemes-1">Indexed-list color schemes</a></h2><p>An &#39;indexed list&#39; color scheme looks like this:</p><pre><code class="language-none">_terrain = (
        (0.00, (0.2, 0.2, 0.6)),
        (0.15, (0.0, 0.6, 1.0)),
        (0.25, (0.0, 0.8, 0.4)),
        (0.50, (1.0, 1.0, 0.6)),
        (0.75, (0.5, 0.36, 0.33)),
        (1.00, (1.0, 1.0, 1.0)))</code></pre><p>The first element in each is the point on the color scheme, the second specifies the RGB values at that point.</p><p>The <code>make_indexed_list_colorscheme(indexedlist)</code> function makes a new ColorScheme from an indexed list.</p><pre><code class="language-none">make_indexed_list_colorscheme(_terrain)</code></pre><div><pre><code class="language-julia">_terrain = (
        (0.00, (0.2, 0.2, 0.6)),
        (0.15, (0.0, 0.6, 1.0)),
        (0.25, (0.0, 0.8, 0.4)),
        (0.50, (1.0, 1.0, 0.6)),
        (0.75, (0.5, 0.36, 0.33)),
        (1.00, (1.0, 1.0, 1.0)))
terrain = make_indexed_list_colorscheme(_terrain)</code></pre></div><p><img src="../assets/figures/terrain.svg" alt="&quot;indexed lists scheme&quot;"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ColorSchemeTools.make_indexed_list_colorscheme" href="#ColorSchemeTools.make_indexed_list_colorscheme"><code>ColorSchemeTools.make_indexed_list_colorscheme</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">make_indexed_list_colorscheme(indexedlist, name::Symbol;
    length=100)</code></pre><p>Make a colorscheme using an &#39;indexed list&#39; like this:</p><pre><code class="language-none">gist_rainbow = (
       (0.000, (1.00, 0.00, 0.16)),
       (0.030, (1.00, 0.00, 0.00)),
       (0.215, (1.00, 1.00, 0.00)),
       (0.400, (0.00, 1.00, 0.00)),
       (0.586, (0.00, 1.00, 1.00)),
       (0.770, (0.00, 0.00, 1.00)),
       (0.954, (1.00, 0.00, 1.00)),
       (1.000, (1.00, 0.00, 0.75))
)

The first element of this list of tuples is the point on the color scheme.

make_indexed_list_colorscheme(gist_rainbow)</code></pre></div></div></section><h2><a class="nav-anchor" id="Functional-color-schemes-1" href="#Functional-color-schemes-1">Functional color schemes</a></h2><p>The colors in a &#39;functional&#39; color scheme are produced by three functions that calculate the color values at each point on the scheme.</p><p>The <code>make_functional_colorscheme()</code> function takes three functions and applies them at each point on the colorscheme.</p><div><pre><code class="language-julia">fscheme = make_functional_colorscheme(sqrt, sin, cos)</code></pre></div><p><img src="../assets/figures/funcschemecurves.svg" alt="&quot;functional color schemes&quot;"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ColorSchemeTools.make_functional_colorscheme" href="#ColorSchemeTools.make_functional_colorscheme"><code>ColorSchemeTools.make_functional_colorscheme</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">make_functional_colorscheme(redfunction, greenfunction, bluefunction;
        length=100)</code></pre><p>Make a colorscheme using functions. Each function should return a value between 0 and 1 for that color component at each point on the colorscheme.</p><p><strong>Examples</strong></p><pre><code class="language-none">make_functional_colorscheme(identity, identity, identity)</code></pre><p>returns a smooth black to white gradient, because the <code>identity()</code> function gives back as good as it gets.</p><pre><code class="language-none">make_functional_colorscheme((n) -&gt; round(n, digits=1), (n) -&gt; round(n, digits=1), (n) -&gt; round(n, digits=1))</code></pre><p>returns a stepped gradient, as each point on the scheme is nudged to the nearest multiple of 0.1.</p><pre><code class="language-none">make_functional_colorscheme(n -&gt; sin(n * π), (n) -&gt; 0, (n) -&gt; 0)</code></pre><p>returns a colorscheme that goes from black to red and back again.</p><pre><code class="language-none">ripple10(n) = sin(2π * 10n)
ripple13(n) = sin(2π * 13n)
ripple17(n) = sin(2π * 17n)
make_functional_colorscheme(ripple10, ripple13, ripple17, length=400)</code></pre><p>produces a stripey colorscheme as the rippling sine waves continually change phase.</p></div></div></section><footer><hr/><a class="previous" href="../convertingimages/"><span class="direction">Previous</span><span class="title">Converting image colors</span></a><a class="next" href="../output/"><span class="direction">Next</span><span class="title">Saving colorschemes</span></a></footer></article></body></html>
